// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"
	"gva-lbx/app/model"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newOperationRecord(db *gorm.DB, opts ...gen.DOOption) operationRecord {
	_operationRecord := operationRecord{}

	_operationRecord.operationRecordDo.UseDB(db, opts...)
	_operationRecord.operationRecordDo.UseModel(&model.OperationRecord{})

	tableName := _operationRecord.operationRecordDo.TableName()
	_operationRecord.ALL = field.NewAsterisk(tableName)
	_operationRecord.ID = field.NewUint(tableName, "id")
	_operationRecord.CreatedAt = field.NewTime(tableName, "created_at")
	_operationRecord.UpdatedAt = field.NewTime(tableName, "updated_at")
	_operationRecord.DeletedAt = field.NewTime(tableName, "deleted_at")
	_operationRecord.IsDelete = field.NewField(tableName, "is_delete")
	_operationRecord.Ip = field.NewString(tableName, "ip")
	_operationRecord.Path = field.NewString(tableName, "path")
	_operationRecord.Agent = field.NewString(tableName, "agent")
	_operationRecord.Method = field.NewString(tableName, "method")
	_operationRecord.Request = field.NewString(tableName, "request")
	_operationRecord.Response = field.NewString(tableName, "response")
	_operationRecord.ErrorMessage = field.NewString(tableName, "error_message")
	_operationRecord.Status = field.NewInt(tableName, "status")
	_operationRecord.Latency = field.NewInt64(tableName, "latency")
	_operationRecord.UserId = field.NewInt(tableName, "user_id")
	_operationRecord.User = operationRecordHasOneUser{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("User", "model.User"),
		Role: struct {
			field.RelationField
			Users struct {
				field.RelationField
			}
			Menus struct {
				field.RelationField
				Parameters struct {
					field.RelationField
				}
				Roles struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("User.Role", "model.Role"),
			Users: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("User.Role.Users", "model.User"),
			},
			Menus: struct {
				field.RelationField
				Parameters struct {
					field.RelationField
				}
				Roles struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("User.Role.Menus", "model.Menu"),
				Parameters: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("User.Role.Menus.Parameters", "model.MenuParameter"),
				},
				Roles: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("User.Role.Menus.Roles", "model.Role"),
				},
			},
		},
		Roles: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("User.Roles", "model.Role"),
		},
	}

	_operationRecord.fillFieldMap()

	return _operationRecord
}

type operationRecord struct {
	operationRecordDo operationRecordDo

	ALL          field.Asterisk
	ID           field.Uint
	CreatedAt    field.Time
	UpdatedAt    field.Time
	DeletedAt    field.Time
	IsDelete     field.Field
	Ip           field.String
	Path         field.String
	Agent        field.String
	Method       field.String
	Request      field.String
	Response     field.String
	ErrorMessage field.String
	Status       field.Int
	Latency      field.Int64
	UserId       field.Int
	User         operationRecordHasOneUser

	fieldMap map[string]field.Expr
}

func (o operationRecord) Table(newTableName string) *operationRecord {
	o.operationRecordDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o operationRecord) As(alias string) *operationRecord {
	o.operationRecordDo.DO = *(o.operationRecordDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *operationRecord) updateTableName(table string) *operationRecord {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewUint(table, "id")
	o.CreatedAt = field.NewTime(table, "created_at")
	o.UpdatedAt = field.NewTime(table, "updated_at")
	o.DeletedAt = field.NewTime(table, "deleted_at")
	o.IsDelete = field.NewField(table, "is_delete")
	o.Ip = field.NewString(table, "ip")
	o.Path = field.NewString(table, "path")
	o.Agent = field.NewString(table, "agent")
	o.Method = field.NewString(table, "method")
	o.Request = field.NewString(table, "request")
	o.Response = field.NewString(table, "response")
	o.ErrorMessage = field.NewString(table, "error_message")
	o.Status = field.NewInt(table, "status")
	o.Latency = field.NewInt64(table, "latency")
	o.UserId = field.NewInt(table, "user_id")

	o.fillFieldMap()

	return o
}

func (o *operationRecord) WithContext(ctx context.Context) IOperationRecordDo {
	return o.operationRecordDo.WithContext(ctx)
}

func (o operationRecord) TableName() string { return o.operationRecordDo.TableName() }

func (o operationRecord) Alias() string { return o.operationRecordDo.Alias() }

func (o *operationRecord) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *operationRecord) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 16)
	o.fieldMap["id"] = o.ID
	o.fieldMap["created_at"] = o.CreatedAt
	o.fieldMap["updated_at"] = o.UpdatedAt
	o.fieldMap["deleted_at"] = o.DeletedAt
	o.fieldMap["is_delete"] = o.IsDelete
	o.fieldMap["ip"] = o.Ip
	o.fieldMap["path"] = o.Path
	o.fieldMap["agent"] = o.Agent
	o.fieldMap["method"] = o.Method
	o.fieldMap["request"] = o.Request
	o.fieldMap["response"] = o.Response
	o.fieldMap["error_message"] = o.ErrorMessage
	o.fieldMap["status"] = o.Status
	o.fieldMap["latency"] = o.Latency
	o.fieldMap["user_id"] = o.UserId

}

func (o operationRecord) clone(db *gorm.DB) operationRecord {
	o.operationRecordDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o operationRecord) replaceDB(db *gorm.DB) operationRecord {
	o.operationRecordDo.ReplaceDB(db)
	return o
}

type operationRecordHasOneUser struct {
	db *gorm.DB

	field.RelationField

	Role struct {
		field.RelationField
		Users struct {
			field.RelationField
		}
		Menus struct {
			field.RelationField
			Parameters struct {
				field.RelationField
			}
			Roles struct {
				field.RelationField
			}
		}
	}
	Roles struct {
		field.RelationField
	}
}

func (a operationRecordHasOneUser) Where(conds ...field.Expr) *operationRecordHasOneUser {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a operationRecordHasOneUser) WithContext(ctx context.Context) *operationRecordHasOneUser {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a operationRecordHasOneUser) Model(m *model.OperationRecord) *operationRecordHasOneUserTx {
	return &operationRecordHasOneUserTx{a.db.Model(m).Association(a.Name())}
}

type operationRecordHasOneUserTx struct{ tx *gorm.Association }

func (a operationRecordHasOneUserTx) Find() (result *model.User, err error) {
	return result, a.tx.Find(&result)
}

func (a operationRecordHasOneUserTx) Append(values ...*model.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a operationRecordHasOneUserTx) Replace(values ...*model.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a operationRecordHasOneUserTx) Delete(values ...*model.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a operationRecordHasOneUserTx) Clear() error {
	return a.tx.Clear()
}

func (a operationRecordHasOneUserTx) Count() int64 {
	return a.tx.Count()
}

type operationRecordDo struct{ gen.DO }

type IOperationRecordDo interface {
	gen.SubQuery
	Debug() IOperationRecordDo
	WithContext(ctx context.Context) IOperationRecordDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOperationRecordDo
	WriteDB() IOperationRecordDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOperationRecordDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOperationRecordDo
	Not(conds ...gen.Condition) IOperationRecordDo
	Or(conds ...gen.Condition) IOperationRecordDo
	Select(conds ...field.Expr) IOperationRecordDo
	Where(conds ...gen.Condition) IOperationRecordDo
	Order(conds ...field.Expr) IOperationRecordDo
	Distinct(cols ...field.Expr) IOperationRecordDo
	Omit(cols ...field.Expr) IOperationRecordDo
	Join(table schema.Tabler, on ...field.Expr) IOperationRecordDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOperationRecordDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOperationRecordDo
	Group(cols ...field.Expr) IOperationRecordDo
	Having(conds ...gen.Condition) IOperationRecordDo
	Limit(limit int) IOperationRecordDo
	Offset(offset int) IOperationRecordDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOperationRecordDo
	Unscoped() IOperationRecordDo
	Create(values ...*model.OperationRecord) error
	CreateInBatches(values []*model.OperationRecord, batchSize int) error
	Save(values ...*model.OperationRecord) error
	First() (*model.OperationRecord, error)
	Take() (*model.OperationRecord, error)
	Last() (*model.OperationRecord, error)
	Find() ([]*model.OperationRecord, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OperationRecord, err error)
	FindInBatches(result *[]*model.OperationRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.OperationRecord) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOperationRecordDo
	Assign(attrs ...field.AssignExpr) IOperationRecordDo
	Joins(fields ...field.RelationField) IOperationRecordDo
	Preload(fields ...field.RelationField) IOperationRecordDo
	FirstOrInit() (*model.OperationRecord, error)
	FirstOrCreate() (*model.OperationRecord, error)
	FindByPage(offset int, limit int) (result []*model.OperationRecord, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOperationRecordDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o operationRecordDo) Debug() IOperationRecordDo {
	return o.withDO(o.DO.Debug())
}

func (o operationRecordDo) WithContext(ctx context.Context) IOperationRecordDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o operationRecordDo) ReadDB() IOperationRecordDo {
	return o.Clauses(dbresolver.Read)
}

func (o operationRecordDo) WriteDB() IOperationRecordDo {
	return o.Clauses(dbresolver.Write)
}

func (o operationRecordDo) Session(config *gorm.Session) IOperationRecordDo {
	return o.withDO(o.DO.Session(config))
}

func (o operationRecordDo) Clauses(conds ...clause.Expression) IOperationRecordDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o operationRecordDo) Returning(value interface{}, columns ...string) IOperationRecordDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o operationRecordDo) Not(conds ...gen.Condition) IOperationRecordDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o operationRecordDo) Or(conds ...gen.Condition) IOperationRecordDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o operationRecordDo) Select(conds ...field.Expr) IOperationRecordDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o operationRecordDo) Where(conds ...gen.Condition) IOperationRecordDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o operationRecordDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IOperationRecordDo {
	return o.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (o operationRecordDo) Order(conds ...field.Expr) IOperationRecordDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o operationRecordDo) Distinct(cols ...field.Expr) IOperationRecordDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o operationRecordDo) Omit(cols ...field.Expr) IOperationRecordDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o operationRecordDo) Join(table schema.Tabler, on ...field.Expr) IOperationRecordDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o operationRecordDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOperationRecordDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o operationRecordDo) RightJoin(table schema.Tabler, on ...field.Expr) IOperationRecordDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o operationRecordDo) Group(cols ...field.Expr) IOperationRecordDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o operationRecordDo) Having(conds ...gen.Condition) IOperationRecordDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o operationRecordDo) Limit(limit int) IOperationRecordDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o operationRecordDo) Offset(offset int) IOperationRecordDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o operationRecordDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOperationRecordDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o operationRecordDo) Unscoped() IOperationRecordDo {
	return o.withDO(o.DO.Unscoped())
}

func (o operationRecordDo) Create(values ...*model.OperationRecord) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o operationRecordDo) CreateInBatches(values []*model.OperationRecord, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o operationRecordDo) Save(values ...*model.OperationRecord) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o operationRecordDo) First() (*model.OperationRecord, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.OperationRecord), nil
	}
}

func (o operationRecordDo) Take() (*model.OperationRecord, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.OperationRecord), nil
	}
}

func (o operationRecordDo) Last() (*model.OperationRecord, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.OperationRecord), nil
	}
}

func (o operationRecordDo) Find() ([]*model.OperationRecord, error) {
	result, err := o.DO.Find()
	return result.([]*model.OperationRecord), err
}

func (o operationRecordDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OperationRecord, err error) {
	buf := make([]*model.OperationRecord, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o operationRecordDo) FindInBatches(result *[]*model.OperationRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o operationRecordDo) Attrs(attrs ...field.AssignExpr) IOperationRecordDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o operationRecordDo) Assign(attrs ...field.AssignExpr) IOperationRecordDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o operationRecordDo) Joins(fields ...field.RelationField) IOperationRecordDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o operationRecordDo) Preload(fields ...field.RelationField) IOperationRecordDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o operationRecordDo) FirstOrInit() (*model.OperationRecord, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.OperationRecord), nil
	}
}

func (o operationRecordDo) FirstOrCreate() (*model.OperationRecord, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.OperationRecord), nil
	}
}

func (o operationRecordDo) FindByPage(offset int, limit int) (result []*model.OperationRecord, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o operationRecordDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o operationRecordDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o operationRecordDo) Delete(models ...*model.OperationRecord) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *operationRecordDo) withDO(do gen.Dao) *operationRecordDo {
	o.DO = *do.(*gen.DO)
	return o
}
